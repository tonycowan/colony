<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Canvas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <canvas class="myCanvas">
        <p>Add suitable fallback here.</p>
    </canvas>

    <script>
        const canvas = document.querySelector('.myCanvas');
        const canvasWidth = canvas.width = window.innerWidth;
        const canvasHeight = canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        const backgroundColor = 'rgb(0, 0, 0)';
        const preyFillStyle = 'rgb(0, 0, 255)';
        const preyStrokeStyle = 'rgb(255, 255, 255)';
        const predatorFillStyle = 'rgb(255, 0, 0)';
        const predatorStrokeStyle = 'rgb(255, 255, 255)';
        const beakColor = 'rgb(200,150,25)';

        const preyCount = 20;
        let preyList = [];

        const predatorCount = 1;
        const predatorList = [];

        const preyRadius = 20;
        const predatorRadius = 30;

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        };

        function rotate(point, rad) {
            // x2=cosβx1−sinβy1
            // y2=sinβx1+cosβy1

            const x2 = Math.cos(rad) * point.x - Math.sin(rad) * point.y;
            const y2 = Math.sin(rad) * point.x + Math.cos(rad) * point.y;

            return { x: x2, y: y2 };
        };

        function rand(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + (min);
        }

        // put 0,0 in the middle of the screen
        ctx.translate(canvasWidth / 2, canvasHeight / 2);

        // erase the screen to the background color
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(-(canvasWidth / 2), -(canvasHeight / 2), canvasWidth, canvasHeight);

        class Drawable {
            constructor(id, x, y, orientation, boundingRadius, fillStyle, strokeStyle) {
                this.id = id;
                this.boundingRadius = boundingRadius;
                this.fillStyle = fillStyle;
                this.strokeStyle = strokeStyle;
                this.minX = -(canvasWidth / 2) + boundingRadius;
                this.maxX = (canvasWidth / 2) - boundingRadius;
                this.minY = -(canvasHeight / 2) + boundingRadius;
                this.maxY = (canvasHeight / 2) - boundingRadius;
                this.x = x !== undefined ? x : rand(this.minX, this.maxX);
                this.y = y !== undefined ? y : rand(this.minY, this.maxY);
                this.orientation = degToRad(orientation !== undefined ? orientation : rand(0, 359));
                this.boundCheck();
            }

            drawBoundingCircle(fillStyle, strokeStyle) {
                let fontHeight = 36;
                let fontWidth = 25;
                ctx.fillStyle = fillStyle;
                ctx.strokeStyle = strokeStyle;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.boundingRadius, degToRad(0), degToRad(360), false);
                ctx.fill();
                ctx.stroke();

                // the beak has 3 points p1, p2, p3
                const p1 = rotate({ x: 0, y: - this.boundingRadius }, this.orientation);
                const p2 = rotate({ x: 0, y: this.boundingRadius }, this.orientation);
                const p3 = rotate({ x: this.boundingRadius, y: 0 }, this.orientation);

                ctx.beginPath();
                ctx.moveTo(this.x + p1.x, this.y + p1.y);
                ctx.lineTo(this.x + p2.x, this.y + p2.y);
                ctx.lineTo(this.x + p3.x, this.y + p3.y);
                ctx.fillStyle = beakColor;
                ctx.fill();

                ctx.font = '36px arial';
                ctx.strokeText(this.id, this.x - fontWidth / 2, this.y + fontHeight / 2);
            }
            draw() {
                this.drawBoundingCircle(this.fillStyle, this.strokeStyle);
            }
            erase() {
                this.drawBoundingCircle(backgroundColor, backgroundColor);
            }
            moveBy(xDiff, yDiff) {
                this.moveTo(this.x + xDiff, this.y + yDiff);
            }
            moveTo(x, y) {
                this.x = x;
                this.y = y;

                this.boundCheck();
            }
            boundCheck() {
                this.x = this.x > this.maxX ? this.maxX : this.x;
                this.x = this.x < this.minX ? this.minX : this.x;
                this.y = this.y > this.maxY ? this.maxY : this.y;
                this.y = this.y < this.minY ? this.minY : this.y;
            }
        }


        class Prey extends Drawable {
            // we will represent prey as a circle of radius "boundingRadius"

            maxMoveLength = 2;
            viewAngle = degToRad(270);
            turnStep = degToRad(5); // degrees maximum gurn per step

            constructor(id, x, y, orientation) {
                super(id, x, y, orientation, preyRadius, preyFillStyle, preyStrokeStyle);
            }

            draw() {
                super.draw();
                const orientation = this.orientation;
                const viewAngle = this.viewAngle;
                //const angleToOther = Math.atan((u.y - this.y) / (u.x - this.x));
                //const inView = Math.abs(orientation - angleToOther) <= Math.abs(orientation - viewAngle / 2)

                /*
                                let orientation = degToRad(30);
                                let angle = degToRad(25);
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(100 * Math.cos(orientation + angle), 100 * Math.sin(orientation + angle));
                                //ctx.lineTo(100 * Math.cos(orientation - angle), 100 * Math.sin(orientation - angle));
                                //console.log(`orientation: ${orientation}, angle: ${angle}, p1: {${100 * Math.cos(orientation + angle)},${100 * Math.sin(orientation + angle)}}, p2: {${100 * Math.cos(orientation - angle)},${100 * Math.sin(orientation - angle)}}`);
                                ctx.arc(0, 0, 100, orientation + angle, orientation - angle, true);
                                ctx.lineTo(0, 0);
                                ctx.fillStyle = 'rgba(150,150,255,0.7)';
                                ctx.fill();
                */



/*
                ctx.beginPath();
                ctx.moveTo(this.x + 100 * Math.cos(orientation), this.y + 100 * Math.sin(orientation));
                ctx.lineTo(this.x, this.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                //ctx.lineTo(this.x - 50 * Math.sin(orientation + viewAngle / 2), this.y + 50 * Math.cos(orientation + viewAngle / 2));
                ctx.lineTo(this.x + 50 * Math.cos(orientation + viewAngle / 2), this.y + 50 * Math.sin(orientation + viewAngle / 2));
                ctx.arc(this.x, this.y, 50, orientation + viewAngle / 2, orientation - viewAngle / 2, true);
                ctx.lineTo(this.x, this.y);
                ctx.fillStyle = "rgba(100,100,255,0.5)";
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + 50 * Math.cos(orientation - viewAngle / 2), this.y + 50 * Math.sin(orientation - viewAngle / 2));
                ctx.lineTo(this.x + 50 * Math.cos(orientation + viewAngle / 2), this.y + 50 * Math.sin(orientation + viewAngle / 2));
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = "rgba(255,100,100,1)";
                ctx.stroke();


                console.log(`id: ${this.id}, orientation: ${this.orientation}, viewAngle: ${viewAngle}, x: ${this.x}, y: ${this.y}, pointer.x: ${this.x + 100 * Math.sin(orientation)}, pointer.y: ${this.y + 100 * Math.cos(orientation)}`);
                */
            }

            move() {
                // let every other prey influence this prey in inverse
                // proportion to the distance between them

                // prey attempt to maintain a constant distance of one radius 
                // from all other prey

                // prey can move at most 1/10 radius per move only in the direction of orientation.
                // prey can turn at most "turnstep" (e.g.: 5) degrees at a time

                // prey cannot move off the screen

                // first the attraction to the visible flock
                const orientation = this.orientation;

                let vectors = preyList.reduce((a, u) => {
                    // we want the distance between unit centers to be 3 boundingRadius
                    const requiredOffsetDistance = 3 * this.boundingRadius;
                    // determine if the other flock member is in view (within 1/2 view angle of orientation)
                    const viewAngle = this.viewAngle;
                    const vectorToOther = {x:u.x-this.x, y:u.y-this.y};
                    const unitZero = {x:1,y:0};
                    const angleToOther = Math.acos((vectorToOther.x)/Math.sqrt(vectorToOther.x*vectorToOther.x+vectorToOther.y*vectorToOther.y)) * Math.sign(vectorToOther.y);
                    const unitOther = { x: Math.cos(angleToOther), y: Math.sin(angleToOther) };
                    const unitOrientation = { x: Math.cos(orientation), y: Math.sin(orientation) };
                    const orientationToOther = Math.acos((unitOther.x * unitOrientation.x + unitOther.y * unitOrientation.y));
                    const inView = Math.abs(orientationToOther) <= Math.abs(viewAngle / 2);
                    
                    /*
                    console.log(`id: ${this.id}@(${this.x},${this.y}), other: ${u.id}@(${u.x},${u.y}), orientationToOther: ${orientationToOther}, orientation: ${orientation}:${unitOrientation}, angleToOther: ${angleToOther}:${unitOther}, inView: ${inView}`, a);

                    ctx.beginPath();
                    ctx.moveTo(this.x + 1000 * Math.cos(angleToOther), this.y + 1000 * Math.sin(angleToOther));
                    ctx.lineTo(this.x, this.y);
                    ctx.strokeStyle = inView ? 'rgba(0,255,0,0.8' : 'rgba(255,0,0,0.8)';
                    ctx.stroke();

                    let fontHeight = 36;
                    let fontWidth = 25;

                    ctx.font = '36px arial';
                    ctx.strokeText(u.id, this.x + 100 * Math.cos(angleToOther) - fontWidth / 2, this.y + 100 * Math.sin(angleToOther) + fontHeight / 2);
*/


                    if (inView) {
                        let centerToCenter = { x: u.x - this.x, y: u.y - this.y };
                        let distance = Math.sqrt(centerToCenter.x * centerToCenter.x + centerToCenter.y * centerToCenter.y);
                        let requiredOffsetVector = { x: centerToCenter.x * requiredOffsetDistance / distance, y: centerToCenter.y * requiredOffsetDistance / distance };
                        let vector = { from: u.id, to: this.id, centerToCenter, distance, requiredOffsetVector, x: distance > 0 ? Math.round((centerToCenter.x - requiredOffsetVector.x)) : 0, y: distance > 0 ? Math.round((centerToCenter.y - requiredOffsetVector.y)) : 0 };
                        vector.tooClose = distance < requiredOffsetDistance;

                        a.push(vector);
                    }

                    return a;
                }, []);

                // now aversion to predatorList
                predatorList.forEach((u) => {
                    // we want the distance between unit centers to be 3 boundingRadii
                    const panicDistance = 4 * this.boundingRadius;
                    let centerToCenter = { x: this.x - u.x, y: this.y - u.y };
                    let distance = Math.sqrt(centerToCenter.x * centerToCenter.x + centerToCenter.y * centerToCenter.y);
                    let vector = { from: u.id, to: this.id, centerToCenter, distance, x: distance > 0 ? Math.round(centerToCenter.x) : 0, y: distance > 0 ? Math.round(centerToCenter.y) : 0 };
                    vector.tooClose = distance < panicDistance;

                    vectors.push(vector);
                });

                let scaledVectors = vectors.map((v) => {
                    // effectively multiply forces by a constant by dividing scale factor by the same amount - this separates the signal from the noise.
                    let scale = (v.x * v.x + v.y * v.y) / 30;
                    return { from: v.from, to: v.to, vx: v.x, vy: v.y, scale, x: scale != 0 ? v.x / (v.tooClose ? 1 : scale) : 0, y: scale != 0 ? v.y / (v.tooClose ? 1 : scale) : 0 };
                });
                //console.log('scaledVectors:', scaledVectors);

                let sum = scaledVectors.reduce((a, v) => ({ x: a.x + v.x, y: a.y + v.y }), { x: 0, y: 0 });

                const unitOrientation = { x: Math.cos(orientation), y: Math.sin(orientation) };
                const orientationToForceAngle = Math.sign(sum.y - unitOrientation.y) * Math.acos((sum.x||sum.y)?(sum.x * unitOrientation.x + sum.y * unitOrientation.y) / Math.sqrt(sum.x * sum.x + sum.y * sum.y):0);
                if (Math.abs(orientationToForceAngle) <= this.turnStep) {
                    this.orientation += orientationToForceAngle;
                } else {
                    this.orientation += Math.sign(orientationToForceAngle) * this.turnStep;
                }
                if(Number.isNaN(this.orientation)){
    console.log(`uox: ${unitOrientation.x}, ouy: ${unitOrientation.y}, sx: ${sum.x}, sy: ${sum.y}, otfa: ${orientationToForceAngle}`);
}

                let forceScale = Math.sqrt(sum.x * sum.x + sum.y * sum.y);
                let moveVector = unitOrientation;

                if (forceScale > this.maxMoveLength) {
                    // scale it back
                    moveVector = { x: unitOrientation.x * this.maxMoveLength, y: unitOrientation.y * this.maxMoveLength };
                } else {
                    moveVector = { x: unitOrientation.x * forceScale, y: unitOrientation.y * forceScale };
                }
                this.moveBy(moveVector.x, moveVector.y);
            }
        }

        class Predator extends Drawable {
            // we will represent prey as a circle of radius "boundingRadius"

            maxMoveLength = 3;
            viewAngle = degToRad(180);
            turnStep = degToRad(5); // degrees maximum gurn per step

            constructor(id, x, y, orientation) {
                super(id, x, y, orientation, predatorRadius, predatorFillStyle, predatorStrokeStyle);
            }

            move() {
                // predators are attracted to all prey just as prey are attracted to each other in inverse proportion to the distance
                // predators cannot move off screen
                const orientation = this.orientation;
/*
                let vectors = preyList.map((u) => {
                    let centerToCenter = { x: u.x - this.x, y: u.y - this.y };
                    let distance = Math.sqrt(centerToCenter.x * centerToCenter.x + centerToCenter.y * centerToCenter.y);
                    let vector = { from: u.id, to: this.id, centerToCenter, distance, x: distance > 0 ? Math.round((centerToCenter.x)) : 0, y: distance > 0 ? Math.round((centerToCenter.y)) : 0 };

                    return vector;
                });
*/
                let vectors = preyList.reduce((a, u) => {
                    // we want the distance between unit centers to be 3 boundingRadius
                    const requiredOffsetDistance = 3 * this.boundingRadius;
                    // determine if the other flock member is in view (within 1/2 view angle of orientation)
                    const viewAngle = this.viewAngle;
                    const vectorToOther = {x:u.x-this.x, y:u.y-this.y};
                    const unitZero = {x:1,y:0};
                    const angleToOther = Math.acos((vectorToOther.x)/Math.sqrt(vectorToOther.x*vectorToOther.x+vectorToOther.y*vectorToOther.y)) * Math.sign(vectorToOther.y);
                    const unitOther = { x: Math.cos(angleToOther), y: Math.sin(angleToOther) };
                    const unitOrientation = { x: Math.cos(orientation), y: Math.sin(orientation) };
                    const orientationToOther = Math.acos((unitOther.x * unitOrientation.x + unitOther.y * unitOrientation.y));
                    const inView = Math.abs(orientationToOther) <= Math.abs(viewAngle / 2);

                    if (inView) {
                        let centerToCenter = { x: u.x - this.x, y: u.y - this.y };
                        let distance = Math.sqrt(centerToCenter.x * centerToCenter.x + centerToCenter.y * centerToCenter.y);
                        let vector = { from: u.id, to: this.id, centerToCenter, distance, x: distance > 0 ? Math.round((centerToCenter.x)) : 0, y: distance > 0 ? Math.round((centerToCenter.y)) : 0 };

                        a.push(vector);
                    }

                    return a;
                }, []);


                // did we catch any?
                vectors.forEach((v) => {
                    // we don't handle the case where prey is hiding in a corner of the screen
                    if (Math.floor(v.distance) <= predatorRadius - preyRadius) {
                        console.log(`********** got 'im ************ ${v.from} (${preyList.length} left out of ${preyCount}`);
                        preyList = preyList.filter((u) => u.id != v.from);
                    }
                });

                let scaledVectors = vectors.map((v) => {
                    // effectively multiply forces by 10 by dividing scale factor by 10
                    let distance = Math.sqrt(v.x * v.x + v.y * v.y)
                    let scale = distance * distance * distance / 10000;
                    return { from: v.from, to: v.to, vx: v.x, vy: v.y, scale, x: scale != 0 ? v.x / scale : 0, y: scale != 0 ? v.y / scale : 0 };
                });
                //console.log('scaledVectors:', scaledVectors);
                let sum = scaledVectors.reduce((a, v) => ({ x: a.x + v.x, y: a.y + v.y }), { x: 0, y: 0 });


/*
                let dist = Math.sqrt(sum.x * sum.x + sum.y * sum.y);
                let moveVector = sum;

                if (dist > this.maxMoveLength) {
                    // scale it back
                    let scaledSum = { x: sum.x / dist, y: sum.y / dist };
                    moveVector = { x: scaledSum.x * this.maxMoveLength, y: scaledSum.y * this.maxMoveLength };
                }
*/

                const unitOrientation = { x: Math.cos(orientation), y: Math.sin(orientation) };
                const orientationToForceAngle = Math.sign(sum.y - unitOrientation.y) * Math.acos((sum.x||sum.y)?(sum.x * unitOrientation.x + sum.y * unitOrientation.y) / (Math.sqrt(sum.x * sum.x + sum.y * sum.y)):0);
                if (Math.abs(orientationToForceAngle) <= this.turnStep) {
                    this.orientation += orientationToForceAngle;
                } else {
                    this.orientation += Math.sign(orientationToForceAngle) * this.turnStep;
                }

                let forceScale = Math.sqrt(sum.x * sum.x + sum.y * sum.y);
                let moveVector = unitOrientation;

                if (forceScale > this.maxMoveLength) {
                    // scale it back
                    moveVector = { x: unitOrientation.x * this.maxMoveLength, y: unitOrientation.y * this.maxMoveLength };
                } else {
                    moveVector = { x: unitOrientation.x * forceScale, y: unitOrientation.y * forceScale };
                }




                this.moveBy(moveVector.x, moveVector.y);
            }
        }

        for (let i = 0; i < preyCount; i++) {
            const prey = new Prey(i);
            preyList.push(prey);
            console.log(prey);
        }

        for (let i = 0; i < predatorCount; i++) {
            const predator = new Predator(i);
            predatorList.push(predator);
            console.log(predator);
        }

        let moveCount = 0;
        function loop() {

            preyList.forEach((prey) => {
                prey.erase();
                prey.move();
                prey.draw();
            });

            predatorList.forEach((predator) => {
                predator.erase();
                predator.move();
                predator.draw();
            });

            if (moveCount++ < 1000)
                requestAnimationFrame(loop);

            //console.log('we have prey: ',preyList);
        }

        loop();
/*
                ctx.beginPath();
                ctx.moveTo(-100, 100);
                ctx.lineTo(100, 100);
                ctx.lineTo(100, -100);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-5, 5);
                ctx.lineTo(5, 5);
                ctx.lineTo(5, -5);
                ctx.lineTo(-5, -5);
                ctx.fillStyle = 'rgba(255,255,255,1)';
                ctx.fill();
        
                ctx.beginPath();
                ctx.arc(0, 0, 100, 0, 2 * Math.PI, false);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.stroke();
        
                let orientation = degToRad(30);
                let angle = degToRad(25);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(100 * Math.cos(orientation + angle), 100 * Math.sin(orientation + angle));
                //ctx.lineTo(100 * Math.cos(orientation - angle), 100 * Math.sin(orientation - angle));
                //console.log(`orientation: ${orientation}, angle: ${angle}, p1: {${100 * Math.cos(orientation + angle)},${100 * Math.sin(orientation + angle)}}, p2: {${100 * Math.cos(orientation - angle)},${100 * Math.sin(orientation - angle)}}`);
                ctx.arc(0, 0, 100, orientation + angle, orientation - angle, true);
                ctx.lineTo(0, 0);
                ctx.fillStyle = 'rgba(150,150,255,0.7)';
                ctx.fill();
        */
    </script>
</body>

</html>